/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
import { Injectable, Optional, Inject } from '@angular/core';
import { ReplaySubject, fromEvent, of, throwError, race } from 'rxjs';
import { map, mergeMap, first, tap } from 'rxjs/operators';
import { LocalStorageDatabase } from './localstorage-database';
import { MockLocalDatabase } from './mock-local-database';
import { LOCAL_STORAGE_PREFIX } from '../tokens';
import * as i0 from "@angular/core";
import * as i1 from "../tokens";
var IndexedDBDatabase = /** @class */ (function () {
    /**
     * Connects to IndexedDB
     */
    function IndexedDBDatabase(prefix) {
        if (prefix === void 0) { prefix = null; }
        this.prefix = prefix;
        /**
         * IndexedDB database name for local storage
         */
        this.dbName = 'ngStorage';
        /**
         * IndexedDB object store name for local storage
         */
        this.objectStoreName = 'localStorage';
        /**
         * IndexedDB key path name for local storage (where an item's key will be stored)
         */
        this.keyPath = 'key';
        /**
         * IndexedDB data path name for local storage (where items' value will be stored)
         */
        this.dataPath = 'value';
        /**
         * IndexedDB is available but failing in some scenarios (Firefox private mode, Safari cross-origin iframes),
         * so a fallback can be needed.
         */
        this.fallback = null;
        if (prefix) {
            this.dbName = prefix + "_" + this.dbName;
        }
        /* Creating the RxJS ReplaySubject */
        this.database = new ReplaySubject();
        /* Connecting to IndexedDB */
        this.connect(prefix);
    }
    /**
     * Gets an item value in local storage
     * @param key The item's key
     * @returns The item's value if the key exists, null otherwise, wrapped in an RxJS Observable
     */
    /**
     * Gets an item value in local storage
     * @template T
     * @param {?} key The item's key
     * @return {?} The item's value if the key exists, null otherwise, wrapped in an RxJS Observable
     */
    IndexedDBDatabase.prototype.getItem = /**
     * Gets an item value in local storage
     * @template T
     * @param {?} key The item's key
     * @return {?} The item's value if the key exists, null otherwise, wrapped in an RxJS Observable
     */
    function (key) {
        /* Fallback storage if set */
        if (this.fallback) {
            return this.fallback.getItem(key);
        }
        /* Opening a trasaction and requesting the item in local storage */
        return this.getItemFromTransaction(key);
    };
    /**
     * Internal method to factorize the getter for getItem and setItem,
     * the last one needing to be from a preexisting transaction
     * @template T
     * @param {?} key The item's key
     * @param {?=} transactionParam Optional pre-existing transaction to use for the read request
     * @return {?} The item's value if the key exists, null otherwise, wrapped in an RxJS Observable
     */
    IndexedDBDatabase.prototype.getItemFromTransaction = /**
     * Internal method to factorize the getter for getItem and setItem,
     * the last one needing to be from a preexisting transaction
     * @template T
     * @param {?} key The item's key
     * @param {?=} transactionParam Optional pre-existing transaction to use for the read request
     * @return {?} The item's value if the key exists, null otherwise, wrapped in an RxJS Observable
     */
    function (key, transactionParam) {
        var _this = this;
        var /** @type {?} */ transaction$ = transactionParam ? of(transactionParam) : this.transaction();
        return transaction$.pipe(map(function (transaction) { return transaction.get(key); }), mergeMap(function (request) {
            /* Listening to the success event, and passing the item value if found, null otherwise */
            var /** @type {?} */ success = (/** @type {?} */ (fromEvent(request, 'success'))).pipe(map(function (event) { return (/** @type {?} */ (event.target)).result; }), map(function (result) { return result && (_this.dataPath in result) ? (/** @type {?} */ (result[_this.dataPath])) : null; }));
            /* Merging success and errors events and autoclosing the observable */
            return (/** @type {?} */ (race(success, _this.toErrorObservable(request, "getter"))))
                .pipe(first());
        }), first());
    };
    /**
     * Sets an item in local storage
     * @param key The item's key
     * @param data The item's value, must NOT be null or undefined
     * @returns An RxJS Observable to wait the end of the operation
     */
    /**
     * Sets an item in local storage
     * @param {?} key The item's key
     * @param {?} data The item's value, must NOT be null or undefined
     * @return {?} An RxJS Observable to wait the end of the operation
     */
    IndexedDBDatabase.prototype.setItem = /**
     * Sets an item in local storage
     * @param {?} key The item's key
     * @param {?} data The item's value, must NOT be null or undefined
     * @return {?} An RxJS Observable to wait the end of the operation
     */
    function (key, data) {
        var _this = this;
        /* Fallback storage if set */
        if (this.fallback) {
            return this.fallback.setItem(key, data);
        }
        /* Storing null is not correctly supported by IndexedDB and unnecessary here */
        if (data == null) {
            return of(true);
        }
        /* Transaction must be the same for read and write, to avoid concurrency issues */
        var /** @type {?} */ transaction$ = this.transaction('readwrite');
        var /** @type {?} */ transaction;
        /* Opening a transaction */
        return transaction$.pipe(tap(function (value) {
            transaction = value;
        }), /* Check if the key already exists or not */
        mergeMap(function () { return _this.getItemFromTransaction(key, transaction); }), map(function (existingData) { return (existingData == null) ? 'add' : 'put'; }), mergeMap(function (method) {
            var /** @type {?} */ request;
            /* Adding or updating local storage, based on previous checking */
            switch (method) {
                case 'add':
                    request = transaction.add((_a = {}, _a[_this.dataPath] = data, _a), key);
                    break;
                case 'put':
                default:
                    request = transaction.put((_b = {}, _b[_this.dataPath] = data, _b), key);
                    break;
            }
            /* Merging success (passing true) and error events and autoclosing the observable */
            return (/** @type {?} */ (race(_this.toSuccessObservable(request), _this.toErrorObservable(request, "setter"))))
                .pipe(first());
            var _a, _b;
        }), first());
    };
    /**
     * Deletes an item in local storage
     * @param key The item's key
     * @returns An RxJS Observable to wait the end of the operation
     */
    /**
     * Deletes an item in local storage
     * @param {?} key The item's key
     * @return {?} An RxJS Observable to wait the end of the operation
     */
    IndexedDBDatabase.prototype.removeItem = /**
     * Deletes an item in local storage
     * @param {?} key The item's key
     * @return {?} An RxJS Observable to wait the end of the operation
     */
    function (key) {
        var _this = this;
        /* Fallback storage if set */
        if (this.fallback) {
            return this.fallback.removeItem(key);
        }
        /* Opening a transaction and checking if the item exists in local storage */
        return this.getItem(key).pipe(mergeMap(function (data) {
            /* If the item exists in local storage */
            if (data != null) {
                /* Opening a transaction */
                return _this.transaction('readwrite').pipe(mergeMap(function (transaction) {
                    /* Deleting the item in local storage */
                    var /** @type {?} */ request = transaction.delete(key);
                    /* Merging success (passing true) and error events and autoclosing the observable */
                    return (/** @type {?} */ (race(_this.toSuccessObservable(request), _this.toErrorObservable(request, "remover"))))
                        .pipe(first());
                }));
            }
            /* Passing true if the item does not exist in local storage */
            return of(true);
        }), first());
    };
    /**
     * Deletes all items from local storage
     * @returns An RxJS Observable to wait the end of the operation
     */
    /**
     * Deletes all items from local storage
     * @return {?} An RxJS Observable to wait the end of the operation
     */
    IndexedDBDatabase.prototype.clear = /**
     * Deletes all items from local storage
     * @return {?} An RxJS Observable to wait the end of the operation
     */
    function () {
        var _this = this;
        /* Fallback storage if set */
        if (this.fallback) {
            return this.fallback.clear();
        }
        /* Opening a transaction */
        return this.transaction('readwrite').pipe(mergeMap(function (transaction) {
            /* Deleting all items from local storage */
            var /** @type {?} */ request = transaction.clear();
            /* Merging success (passing true) and error events and autoclosing the observable */
            return (/** @type {?} */ (race(_this.toSuccessObservable(request), _this.toErrorObservable(request, "clearer"))))
                .pipe(first());
        }), first());
    };
    /**
     * Connects to IndexedDB and creates the object store on first time
     */
    /**
     * Connects to IndexedDB and creates the object store on first time
     * @param {?=} prefix
     * @return {?}
     */
    IndexedDBDatabase.prototype.connect = /**
     * Connects to IndexedDB and creates the object store on first time
     * @param {?=} prefix
     * @return {?}
     */
    function (prefix) {
        var _this = this;
        if (prefix === void 0) { prefix = null; }
        var /** @type {?} */ request;
        /* Connecting to IndexedDB */
        try {
            request = indexedDB.open(this.dbName);
        }
        catch (/** @type {?} */ error) {
            /* Fallback storage if IndexedDb connection is failing */
            this.setFallback(prefix);
            return;
        }
        /* Listening the event fired on first connection, creating the object store for local storage */
        (/** @type {?} */ (fromEvent(request, 'upgradeneeded')))
            .pipe(first())
            .subscribe(function (event) {
            /* Getting the database connection */
            var /** @type {?} */ database = /** @type {?} */ ((/** @type {?} */ (event.target)).result);
            /* Checking if the object store already exists, to avoid error */
            if (!database.objectStoreNames.contains(_this.objectStoreName)) {
                /* Creating the object store for local storage */
                database.createObjectStore(_this.objectStoreName);
            }
        });
        /* Listening the success event and converting to an RxJS Observable */
        var /** @type {?} */ success = /** @type {?} */ (fromEvent(request, 'success'));
        /* Merging success and errors events */
        (/** @type {?} */ (race(success, this.toErrorObservable(request, "connection"))))
            .pipe(first())
            .subscribe(function (event) {
            /* Storing the database connection for further access */
            /* Storing the database connection for further access */
            _this.database.next(/** @type {?} */ ((/** @type {?} */ (event.target)).result));
        }, function () {
            /* Fallback storage if IndexedDb connection is failing */
            /* Fallback storage if IndexedDb connection is failing */
            _this.setFallback(prefix);
        });
    };
    /**
     * Opens an IndexedDB transaction and gets the local storage object store
     * @param mode Default to 'readonly' for read operations, or 'readwrite' for write operations
     * @returns An IndexedDB transaction object store, wrapped in an RxJS Observable
     */
    /**
     * Opens an IndexedDB transaction and gets the local storage object store
     * @param {?=} mode Default to 'readonly' for read operations, or 'readwrite' for write operations
     * @return {?} An IndexedDB transaction object store, wrapped in an RxJS Observable
     */
    IndexedDBDatabase.prototype.transaction = /**
     * Opens an IndexedDB transaction and gets the local storage object store
     * @param {?=} mode Default to 'readonly' for read operations, or 'readwrite' for write operations
     * @return {?} An IndexedDB transaction object store, wrapped in an RxJS Observable
     */
    function (mode) {
        var _this = this;
        if (mode === void 0) { mode = 'readonly'; }
        /* From the IndexedDB connection, opening a transaction and getting the local storage objet store */
        return this.database
            .pipe(map(function (database) { return database.transaction([_this.objectStoreName], mode).objectStore(_this.objectStoreName); }));
    };
    /**
     * Transforms a IndexedDB success event in an RxJS Observable
     * @param request The request to listen
     * @returns A RxJS Observable with true value
     */
    /**
     * Transforms a IndexedDB success event in an RxJS Observable
     * @param {?} request The request to listen
     * @return {?} A RxJS Observable with true value
     */
    IndexedDBDatabase.prototype.toSuccessObservable = /**
     * Transforms a IndexedDB success event in an RxJS Observable
     * @param {?} request The request to listen
     * @return {?} A RxJS Observable with true value
     */
    function (request) {
        /* Transforming a IndexedDB success event in an RxJS Observable with true value */
        return (/** @type {?} */ (fromEvent(request, 'success')))
            .pipe(map(function () { return true; }));
    };
    /**
     * Transforms a IndexedDB error event in an RxJS ErrorObservable
     * @param request The request to listen
     * @param error Optionnal details about the error's origin
     * @returns A RxJS ErrorObservable
     */
    /**
     * Transforms a IndexedDB error event in an RxJS ErrorObservable
     * @param {?} request The request to listen
     * @param {?=} error Optionnal details about the error's origin
     * @return {?} A RxJS ErrorObservable
     */
    IndexedDBDatabase.prototype.toErrorObservable = /**
     * Transforms a IndexedDB error event in an RxJS ErrorObservable
     * @param {?} request The request to listen
     * @param {?=} error Optionnal details about the error's origin
     * @return {?} A RxJS ErrorObservable
     */
    function (request, error) {
        if (error === void 0) { error = ""; }
        /* Transforming a IndexedDB error event in an RxJS ErrorObservable */
        return (/** @type {?} */ (fromEvent(request, 'error')))
            .pipe(mergeMap(function () { return throwError(new Error("IndexedDB " + error + " issue : " + ((/** @type {?} */ (request.error))).message + ".")); }));
    };
    /**
     * @param {?} prefix
     * @return {?}
     */
    IndexedDBDatabase.prototype.setFallback = /**
     * @param {?} prefix
     * @return {?}
     */
    function (prefix) {
        /* When storage is fully disabled in browser (via the "Block all cookies" option),
             * just trying to check `localStorage` variable causes a security exception.
             * Prevents https://github.com/cyrilletuzi/angular-async-local-storage/issues/118
             */
        try {
            if ('getItem' in localStorage) {
                /* Fallback to `localStorage` if available */
                this.fallback = new LocalStorageDatabase(prefix);
            }
            else {
                /* Fallback to memory storage otherwise */
                this.fallback = new MockLocalDatabase();
            }
        }
        catch (_a) {
            /* Fallback to memory storage otherwise */
            this.fallback = new MockLocalDatabase();
        }
    };
    IndexedDBDatabase.decorators = [
        { type: Injectable, args: [{
                    providedIn: 'root'
                },] }
    ];
    /** @nocollapse */
    IndexedDBDatabase.ctorParameters = function () { return [
        { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [LOCAL_STORAGE_PREFIX,] }] }
    ]; };
    /** @nocollapse */ IndexedDBDatabase.ngInjectableDef = i0.defineInjectable({ factory: function IndexedDBDatabase_Factory() { return new IndexedDBDatabase(i0.inject(i1.LOCAL_STORAGE_PREFIX, 8)); }, token: IndexedDBDatabase, providedIn: "root" });
    return IndexedDBDatabase;
}());
export { IndexedDBDatabase };
function IndexedDBDatabase_tsickle_Closure_declarations() {
    /**
     * IndexedDB database name for local storage
     * @type {?}
     */
    IndexedDBDatabase.prototype.dbName;
    /**
     * IndexedDB object store name for local storage
     * @type {?}
     */
    IndexedDBDatabase.prototype.objectStoreName;
    /**
     * IndexedDB key path name for local storage (where an item's key will be stored)
     * @type {?}
     */
    IndexedDBDatabase.prototype.keyPath;
    /**
     * IndexedDB data path name for local storage (where items' value will be stored)
     * @type {?}
     */
    IndexedDBDatabase.prototype.dataPath;
    /**
     * IndexedDB database connection, wrapped in a RxJS ReplaySubject to be able to access the connection
     * even after the connection success event happened
     * @type {?}
     */
    IndexedDBDatabase.prototype.database;
    /**
     * IndexedDB is available but failing in some scenarios (Firefox private mode, Safari cross-origin iframes),
     * so a fallback can be needed.
     * @type {?}
     */
    IndexedDBDatabase.prototype.fallback;
    /** @type {?} */
    IndexedDBDatabase.prototype.prefix;
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXhlZGRiLWRhdGFiYXNlLmpzIiwic291cmNlUm9vdCI6Im5nOi8vQG5neC1wd2EvbG9jYWwtc3RvcmFnZS8iLCJzb3VyY2VzIjpbImxpYi9kYXRhYmFzZXMvaW5kZXhlZGRiLWRhdGFiYXNlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7QUFBQSxPQUFPLEVBQUUsVUFBVSxFQUFFLFFBQVEsRUFBRSxNQUFNLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDN0QsT0FBTyxFQUFjLGFBQWEsRUFBRSxTQUFTLEVBQUUsRUFBRSxFQUFFLFVBQVUsRUFBRSxJQUFJLEVBQUUsTUFBTSxNQUFNLENBQUM7QUFDbEYsT0FBTyxFQUFFLEdBQUcsRUFBRSxRQUFRLEVBQUUsS0FBSyxFQUFFLEdBQUcsRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBRzNELE9BQU8sRUFBRSxvQkFBb0IsRUFBRSxNQUFNLHlCQUF5QixDQUFDO0FBQy9ELE9BQU8sRUFBRSxpQkFBaUIsRUFBRSxNQUFNLHVCQUF1QixDQUFDO0FBQzFELE9BQU8sRUFBRSxvQkFBb0IsRUFBRSxNQUFNLFdBQVcsQ0FBQzs7OztJQWtDL0M7O09BRUc7SUFDSCwyQkFBZ0UsTUFBNEI7OENBQUE7UUFBNUIsV0FBTSxHQUFOLE1BQU0sQ0FBc0I7Ozs7c0JBM0J6RSxXQUFXOzs7OytCQUlPLGNBQWM7Ozs7dUJBSXRCLEtBQUs7Ozs7d0JBSUosT0FBTzs7Ozs7d0JBVU0sSUFBSTtRQU83QyxFQUFFLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDO1lBRVgsSUFBSSxDQUFDLE1BQU0sR0FBTSxNQUFNLFNBQUksSUFBSSxDQUFDLE1BQVEsQ0FBQztTQUUxQzs7UUFHRCxJQUFJLENBQUMsUUFBUSxHQUFHLElBQUksYUFBYSxFQUFlLENBQUM7O1FBR2pELElBQUksQ0FBQyxPQUFPLENBQUMsTUFBTSxDQUFDLENBQUM7S0FFdEI7SUFFRDs7OztPQUlHOzs7Ozs7O0lBQ0gsbUNBQU87Ozs7OztJQUFQLFVBQWlCLEdBQVc7O1FBRzFCLEVBQUUsQ0FBQyxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDO1lBQ2xCLE1BQU0sQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLE9BQU8sQ0FBSSxHQUFHLENBQUMsQ0FBQztTQUN0Qzs7UUFHRCxNQUFNLENBQUMsSUFBSSxDQUFDLHNCQUFzQixDQUFJLEdBQUcsQ0FBQyxDQUFDO0tBRTVDOzs7Ozs7Ozs7SUFTTyxrREFBc0I7Ozs7Ozs7O2NBQVUsR0FBVyxFQUFFLGdCQUFpQzs7UUFFcEYscUJBQU0sWUFBWSxHQUFHLGdCQUFnQixDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsZ0JBQWdCLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLFdBQVcsRUFBRSxDQUFDO1FBRWxGLE1BQU0sQ0FBQyxZQUFZLENBQUMsSUFBSSxDQUN0QixHQUFHLENBQUMsVUFBQyxXQUFXLElBQUssT0FBQSxXQUFXLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxFQUFwQixDQUFvQixDQUFDLEVBQzFDLFFBQVEsQ0FBQyxVQUFDLE9BQU87O1lBR2YscUJBQU0sT0FBTyxHQUFHLG1CQUFDLFNBQVMsQ0FBQyxPQUFPLEVBQUUsU0FBUyxDQUFzQixFQUFDLENBQUMsSUFBSSxDQUN2RSxHQUFHLENBQUMsVUFBQyxLQUFLLElBQUssT0FBQSxtQkFBQyxLQUFLLENBQUMsTUFBb0IsRUFBQyxDQUFDLE1BQU0sRUFBbkMsQ0FBbUMsQ0FBQyxFQUNuRCxHQUFHLENBQUMsVUFBQyxNQUFNLElBQUssT0FBQSxNQUFNLElBQUksQ0FBQyxLQUFJLENBQUMsUUFBUSxJQUFJLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxtQkFBQyxNQUFNLENBQUMsS0FBSSxDQUFDLFFBQVEsQ0FBTSxFQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksRUFBekUsQ0FBeUUsQ0FBQyxDQUMzRixDQUFDOztZQUdGLE1BQU0sQ0FBQyxtQkFBQyxJQUFJLENBQUMsT0FBTyxFQUFFLEtBQUksQ0FBQyxpQkFBaUIsQ0FBQyxPQUFPLEVBQUUsUUFBUSxDQUFDLENBQXlCLEVBQUM7aUJBQ3RGLElBQUksQ0FBQyxLQUFLLEVBQUUsQ0FBQyxDQUFDO1NBQ2xCLENBQUMsRUFDRixLQUFLLEVBQUUsQ0FDUixDQUFDOztJQUlKOzs7OztPQUtHOzs7Ozs7O0lBQ0gsbUNBQU87Ozs7OztJQUFQLFVBQVEsR0FBVyxFQUFFLElBQVM7UUFBOUIsaUJBaURDOztRQTlDQyxFQUFFLENBQUMsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQztZQUNsQixNQUFNLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxPQUFPLENBQUMsR0FBRyxFQUFFLElBQUksQ0FBQyxDQUFDO1NBQ3pDOztRQUdELEVBQUUsQ0FBQyxDQUFDLElBQUksSUFBSSxJQUFJLENBQUMsQ0FBQyxDQUFDO1lBRWpCLE1BQU0sQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLENBQUM7U0FFakI7O1FBR0QscUJBQU0sWUFBWSxHQUFHLElBQUksQ0FBQyxXQUFXLENBQUMsV0FBVyxDQUFDLENBQUM7UUFDbkQscUJBQUksV0FBMkIsQ0FBQzs7UUFHNUIsTUFBTSxDQUFDLFlBQVksQ0FBQyxJQUFJLENBQ3RCLEdBQUcsQ0FBQyxVQUFDLEtBQUs7WUFDUixXQUFXLEdBQUcsS0FBSyxDQUFDO1NBQ3JCLENBQUM7UUFFRixRQUFRLENBQUMsY0FBTSxPQUFBLEtBQUksQ0FBQyxzQkFBc0IsQ0FBQyxHQUFHLEVBQUUsV0FBVyxDQUFDLEVBQTdDLENBQTZDLENBQUMsRUFDN0QsR0FBRyxDQUFDLFVBQUMsWUFBWSxJQUFLLE9BQUEsQ0FBQyxZQUFZLElBQUksSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsS0FBSyxFQUF0QyxDQUFzQyxDQUFDLEVBQzdELFFBQVEsQ0FBQyxVQUFDLE1BQU07WUFFZCxxQkFBSSxPQUFtQixDQUFDOztZQUd4QixNQUFNLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDO2dCQUNmLEtBQUssS0FBSztvQkFDUixPQUFPLEdBQUcsV0FBVyxDQUFDLEdBQUcsV0FBRyxHQUFDLEtBQUksQ0FBQyxRQUFRLElBQUcsSUFBSSxPQUFJLEdBQUcsQ0FBQyxDQUFDO29CQUMxRCxLQUFLLENBQUM7Z0JBQ1IsS0FBSyxLQUFLLENBQUM7Z0JBQ1g7b0JBQ0UsT0FBTyxHQUFHLFdBQVcsQ0FBQyxHQUFHLFdBQUcsR0FBQyxLQUFJLENBQUMsUUFBUSxJQUFHLElBQUksT0FBSSxHQUFHLENBQUMsQ0FBQztvQkFDMUQsS0FBSyxDQUFDO2FBQ1Q7O1lBR0QsTUFBTSxDQUFDLG1CQUFDLElBQUksQ0FBQyxLQUFJLENBQUMsbUJBQW1CLENBQUMsT0FBTyxDQUFDLEVBQUUsS0FBSSxDQUFDLGlCQUFpQixDQUFDLE9BQU8sRUFBRSxRQUFRLENBQUMsQ0FBd0IsRUFBQztpQkFDL0csSUFBSSxDQUFDLEtBQUssRUFBRSxDQUFDLENBQUM7O1NBRXBCLENBQUMsRUFDRixLQUFLLEVBQUUsQ0FDUixDQUFDO0tBRUw7SUFFRDs7OztPQUlHOzs7Ozs7SUFDSCxzQ0FBVTs7Ozs7SUFBVixVQUFXLEdBQVc7UUFBdEIsaUJBbUNDOztRQWhDQyxFQUFFLENBQUMsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQztZQUNsQixNQUFNLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxVQUFVLENBQUMsR0FBRyxDQUFDLENBQUM7U0FDdEM7O1FBR0QsTUFBTSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLENBQUMsSUFBSSxDQUMzQixRQUFRLENBQUMsVUFBQyxJQUFJOztZQUdaLEVBQUUsQ0FBQyxDQUFDLElBQUksSUFBSSxJQUFJLENBQUMsQ0FBQyxDQUFDOztnQkFHakIsTUFBTSxDQUFDLEtBQUksQ0FBQyxXQUFXLENBQUMsV0FBVyxDQUFDLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxVQUFDLFdBQVc7O29CQUc3RCxxQkFBTSxPQUFPLEdBQUcsV0FBVyxDQUFDLE1BQU0sQ0FBQyxHQUFHLENBQUMsQ0FBQzs7b0JBR3hDLE1BQU0sQ0FBQyxtQkFBQyxJQUFJLENBQUMsS0FBSSxDQUFDLG1CQUFtQixDQUFDLE9BQU8sQ0FBQyxFQUFFLEtBQUksQ0FBQyxpQkFBaUIsQ0FBQyxPQUFPLEVBQUUsU0FBUyxDQUFDLENBQXdCLEVBQUM7eUJBQ2hILElBQUksQ0FBQyxLQUFLLEVBQUUsQ0FBQyxDQUFDO2lCQUVsQixDQUFDLENBQUMsQ0FBQzthQUVMOztZQUdELE1BQU0sQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLENBQUM7U0FFakIsQ0FBQyxFQUNGLEtBQUssRUFBRSxDQUNSLENBQUM7S0FFSDtJQUVEOzs7T0FHRzs7Ozs7SUFDSCxpQ0FBSzs7OztJQUFMO1FBQUEsaUJBc0JDOztRQW5CQyxFQUFFLENBQUMsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQztZQUNsQixNQUFNLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxLQUFLLEVBQUUsQ0FBQztTQUM5Qjs7UUFHRCxNQUFNLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxXQUFXLENBQUMsQ0FBQyxJQUFJLENBQ3ZDLFFBQVEsQ0FBQyxVQUFDLFdBQVc7O1lBR25CLHFCQUFNLE9BQU8sR0FBRyxXQUFXLENBQUMsS0FBSyxFQUFFLENBQUM7O1lBR3BDLE1BQU0sQ0FBQyxtQkFBQyxJQUFJLENBQUMsS0FBSSxDQUFDLG1CQUFtQixDQUFDLE9BQU8sQ0FBQyxFQUFFLEtBQUksQ0FBQyxpQkFBaUIsQ0FBQyxPQUFPLEVBQUUsU0FBUyxDQUFDLENBQXdCLEVBQUM7aUJBQ2hILElBQUksQ0FBQyxLQUFLLEVBQUUsQ0FBQyxDQUFDO1NBRWxCLENBQUMsRUFDRixLQUFLLEVBQUUsQ0FDUixDQUFDO0tBRUg7SUFFRDs7T0FFRzs7Ozs7O0lBQ08sbUNBQU87Ozs7O0lBQWpCLFVBQWtCLE1BQTRCO1FBQTlDLGlCQXNEQztRQXREaUIsdUJBQUEsRUFBQSxhQUE0QjtRQUU1QyxxQkFBSSxPQUF5QixDQUFDOztRQUc5QixJQUFJLENBQUM7WUFFSCxPQUFPLEdBQUcsU0FBUyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUM7U0FFdkM7UUFBQyxLQUFLLENBQUMsQ0FBQyxpQkFBQSxLQUFLLEVBQUUsQ0FBQzs7WUFHZixJQUFJLENBQUMsV0FBVyxDQUFDLE1BQU0sQ0FBQyxDQUFDO1lBRXpCLE1BQU0sQ0FBQztTQUVSOztRQUdELG1CQUFDLFNBQVMsQ0FBQyxPQUFPLEVBQUUsZUFBZSxDQUFzQixFQUFDO2FBQ3ZELElBQUksQ0FBQyxLQUFLLEVBQUUsQ0FBQzthQUNiLFNBQVMsQ0FBQyxVQUFDLEtBQUs7O1lBR2YscUJBQU0sUUFBUSxxQkFBRyxtQkFBQyxLQUFLLENBQUMsTUFBb0IsRUFBQyxDQUFDLE1BQXFCLENBQUEsQ0FBQzs7WUFHcEUsRUFBRSxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsZ0JBQWdCLENBQUMsUUFBUSxDQUFDLEtBQUksQ0FBQyxlQUFlLENBQUMsQ0FBQyxDQUFDLENBQUM7O2dCQUc5RCxRQUFRLENBQUMsaUJBQWlCLENBQUMsS0FBSSxDQUFDLGVBQWUsQ0FBQyxDQUFDO2FBRWxEO1NBRUYsQ0FBQyxDQUFDOztRQUdMLHFCQUFNLE9BQU8scUJBQUcsU0FBUyxDQUFDLE9BQU8sRUFBRSxTQUFTLENBQXNCLENBQUEsQ0FBQzs7UUFHbkUsbUJBQUMsSUFBSSxDQUFDLE9BQU8sRUFBRSxJQUFJLENBQUMsaUJBQWlCLENBQUMsT0FBTyxFQUFFLFlBQVksQ0FBQyxDQUFzQixFQUFDO2FBQ2hGLElBQUksQ0FBQyxLQUFLLEVBQUUsQ0FBQzthQUNiLFNBQVMsQ0FBQyxVQUFDLEtBQUs7O1lBR2YsQUFEQSx3REFBd0Q7WUFDeEQsS0FBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLG1CQUFDLG1CQUFDLEtBQUssQ0FBQyxNQUFvQixFQUFDLENBQUMsTUFBcUIsRUFBQyxDQUFDO1NBRXhFLEVBQUU7O1lBR0QsQUFEQSx5REFBeUQ7WUFDekQsS0FBSSxDQUFDLFdBQVcsQ0FBQyxNQUFNLENBQUMsQ0FBQztTQUUxQixDQUFDLENBQUM7S0FFTjtJQUVEOzs7O09BSUc7Ozs7OztJQUNPLHVDQUFXOzs7OztJQUFyQixVQUFzQixJQUEyQztRQUFqRSxpQkFNQztRQU5xQixxQkFBQSxFQUFBLGlCQUEyQzs7UUFHL0QsTUFBTSxDQUFDLElBQUksQ0FBQyxRQUFRO2FBQ2pCLElBQUksQ0FBQyxHQUFHLENBQUMsVUFBQyxRQUFRLElBQUssT0FBQSxRQUFRLENBQUMsV0FBVyxDQUFDLENBQUMsS0FBSSxDQUFDLGVBQWUsQ0FBQyxFQUFFLElBQUksQ0FBQyxDQUFDLFdBQVcsQ0FBQyxLQUFJLENBQUMsZUFBZSxDQUFDLEVBQXBGLENBQW9GLENBQUMsQ0FBQyxDQUFDO0tBRWxIO0lBRUQ7Ozs7T0FJRzs7Ozs7O0lBQ08sK0NBQW1COzs7OztJQUE3QixVQUE4QixPQUFtQjs7UUFHL0MsTUFBTSxDQUFDLG1CQUFDLFNBQVMsQ0FBQyxPQUFPLEVBQUUsU0FBUyxDQUFzQixFQUFDO2FBQ3hELElBQUksQ0FBQyxHQUFHLENBQUMsY0FBTSxPQUFBLElBQUksRUFBSixDQUFJLENBQUMsQ0FBQyxDQUFDO0tBRTFCO0lBRUQ7Ozs7O09BS0c7Ozs7Ozs7SUFDTyw2Q0FBaUI7Ozs7OztJQUEzQixVQUE0QixPQUFtQixFQUFFLEtBQVU7UUFBVixzQkFBQSxFQUFBLFVBQVU7O1FBR3pELE1BQU0sQ0FBQyxtQkFBQyxTQUFTLENBQUMsT0FBTyxFQUFFLE9BQU8sQ0FBc0IsRUFBQzthQUN0RCxJQUFJLENBQUMsUUFBUSxDQUFDLGNBQU0sT0FBQSxVQUFVLENBQUMsSUFBSSxLQUFLLENBQUMsZUFBYSxLQUFLLGlCQUFZLG9CQUFDLE9BQU8sQ0FBQyxLQUFxQixHQUFDLENBQUMsT0FBTyxNQUFHLENBQUMsQ0FBQyxFQUEvRixDQUErRixDQUFDLENBQUMsQ0FBQztLQUUxSDs7Ozs7SUFFUyx1Q0FBVzs7OztJQUFyQixVQUFzQixNQUFxQjs7Ozs7UUFNekMsSUFBSSxDQUFDO1lBRUgsRUFBRSxDQUFDLENBQUMsU0FBUyxJQUFJLFlBQVksQ0FBQyxDQUFDLENBQUM7O2dCQUc5QixJQUFJLENBQUMsUUFBUSxHQUFHLElBQUksb0JBQW9CLENBQUMsTUFBTSxDQUFDLENBQUM7YUFFbEQ7WUFBQyxJQUFJLENBQUMsQ0FBQzs7Z0JBR04sSUFBSSxDQUFDLFFBQVEsR0FBRyxJQUFJLGlCQUFpQixFQUFFLENBQUM7YUFFekM7U0FFRjtRQUFDLEtBQUssQ0FBQyxDQUFDLElBQUQsQ0FBQzs7WUFHUCxJQUFJLENBQUMsUUFBUSxHQUFHLElBQUksaUJBQWlCLEVBQUUsQ0FBQztTQUV6QztLQUVGOztnQkEvVkYsVUFBVSxTQUFDO29CQUNWLFVBQVUsRUFBRSxNQUFNO2lCQUNuQjs7OztnREFpQ2MsUUFBUSxZQUFJLE1BQU0sU0FBQyxvQkFBb0I7Ozs0QkE1Q3REOztTQVlhLGlCQUFpQiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEluamVjdGFibGUsIE9wdGlvbmFsLCBJbmplY3QgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IE9ic2VydmFibGUsIFJlcGxheVN1YmplY3QsIGZyb21FdmVudCwgb2YsIHRocm93RXJyb3IsIHJhY2UgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IG1hcCwgbWVyZ2VNYXAsIGZpcnN0LCB0YXAgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5cbmltcG9ydCB7IExvY2FsRGF0YWJhc2UgfSBmcm9tICcuL2xvY2FsLWRhdGFiYXNlJztcbmltcG9ydCB7IExvY2FsU3RvcmFnZURhdGFiYXNlIH0gZnJvbSAnLi9sb2NhbHN0b3JhZ2UtZGF0YWJhc2UnO1xuaW1wb3J0IHsgTW9ja0xvY2FsRGF0YWJhc2UgfSBmcm9tICcuL21vY2stbG9jYWwtZGF0YWJhc2UnO1xuaW1wb3J0IHsgTE9DQUxfU1RPUkFHRV9QUkVGSVggfSBmcm9tICcuLi90b2tlbnMnO1xuXG5ASW5qZWN0YWJsZSh7XG4gIHByb3ZpZGVkSW46ICdyb290J1xufSlcbmV4cG9ydCBjbGFzcyBJbmRleGVkREJEYXRhYmFzZSBpbXBsZW1lbnRzIExvY2FsRGF0YWJhc2Uge1xuXG4gIC8qKlxuICAgKiBJbmRleGVkREIgZGF0YWJhc2UgbmFtZSBmb3IgbG9jYWwgc3RvcmFnZVxuICAgKi9cbiAgcHJvdGVjdGVkIGRiTmFtZSA9ICduZ1N0b3JhZ2UnO1xuICAvKipcbiAgICogSW5kZXhlZERCIG9iamVjdCBzdG9yZSBuYW1lIGZvciBsb2NhbCBzdG9yYWdlXG4gICAqL1xuICBwcm90ZWN0ZWQgcmVhZG9ubHkgb2JqZWN0U3RvcmVOYW1lID0gJ2xvY2FsU3RvcmFnZSc7XG4gIC8qKlxuICAgKiBJbmRleGVkREIga2V5IHBhdGggbmFtZSBmb3IgbG9jYWwgc3RvcmFnZSAod2hlcmUgYW4gaXRlbSdzIGtleSB3aWxsIGJlIHN0b3JlZClcbiAgICovXG4gIHByb3RlY3RlZCByZWFkb25seSBrZXlQYXRoID0gJ2tleSc7XG4gIC8qKlxuICAgKiBJbmRleGVkREIgZGF0YSBwYXRoIG5hbWUgZm9yIGxvY2FsIHN0b3JhZ2UgKHdoZXJlIGl0ZW1zJyB2YWx1ZSB3aWxsIGJlIHN0b3JlZClcbiAgICovXG4gIHByb3RlY3RlZCByZWFkb25seSBkYXRhUGF0aCA9ICd2YWx1ZSc7XG4gIC8qKlxuICAgKiBJbmRleGVkREIgZGF0YWJhc2UgY29ubmVjdGlvbiwgd3JhcHBlZCBpbiBhIFJ4SlMgUmVwbGF5U3ViamVjdCB0byBiZSBhYmxlIHRvIGFjY2VzcyB0aGUgY29ubmVjdGlvblxuICAgKiBldmVuIGFmdGVyIHRoZSBjb25uZWN0aW9uIHN1Y2Nlc3MgZXZlbnQgaGFwcGVuZWRcbiAgICovXG4gIHByb3RlY3RlZCBkYXRhYmFzZTogUmVwbGF5U3ViamVjdDxJREJEYXRhYmFzZT47XG4gIC8qKlxuICAgKiBJbmRleGVkREIgaXMgYXZhaWxhYmxlIGJ1dCBmYWlsaW5nIGluIHNvbWUgc2NlbmFyaW9zIChGaXJlZm94IHByaXZhdGUgbW9kZSwgU2FmYXJpIGNyb3NzLW9yaWdpbiBpZnJhbWVzKSxcbiAgICogc28gYSBmYWxsYmFjayBjYW4gYmUgbmVlZGVkLlxuICAgKi9cbiAgcHJvdGVjdGVkIGZhbGxiYWNrOiBMb2NhbERhdGFiYXNlIHwgbnVsbCA9IG51bGw7XG5cbiAgLyoqXG4gICAqIENvbm5lY3RzIHRvIEluZGV4ZWREQlxuICAgKi9cbiAgY29uc3RydWN0b3IoQE9wdGlvbmFsKCkgQEluamVjdChMT0NBTF9TVE9SQUdFX1BSRUZJWCkgcHJvdGVjdGVkIHByZWZpeDogc3RyaW5nIHwgbnVsbCA9IG51bGwpIHtcblxuICAgIGlmIChwcmVmaXgpIHtcblxuICAgICAgdGhpcy5kYk5hbWUgPSBgJHtwcmVmaXh9XyR7dGhpcy5kYk5hbWV9YDtcblxuICAgIH1cblxuICAgIC8qIENyZWF0aW5nIHRoZSBSeEpTIFJlcGxheVN1YmplY3QgKi9cbiAgICB0aGlzLmRhdGFiYXNlID0gbmV3IFJlcGxheVN1YmplY3Q8SURCRGF0YWJhc2U+KCk7XG5cbiAgICAvKiBDb25uZWN0aW5nIHRvIEluZGV4ZWREQiAqL1xuICAgIHRoaXMuY29ubmVjdChwcmVmaXgpO1xuXG4gIH1cblxuICAvKipcbiAgICogR2V0cyBhbiBpdGVtIHZhbHVlIGluIGxvY2FsIHN0b3JhZ2VcbiAgICogQHBhcmFtIGtleSBUaGUgaXRlbSdzIGtleVxuICAgKiBAcmV0dXJucyBUaGUgaXRlbSdzIHZhbHVlIGlmIHRoZSBrZXkgZXhpc3RzLCBudWxsIG90aGVyd2lzZSwgd3JhcHBlZCBpbiBhbiBSeEpTIE9ic2VydmFibGVcbiAgICovXG4gIGdldEl0ZW08VCA9IGFueT4oa2V5OiBzdHJpbmcpOiBPYnNlcnZhYmxlPFTCoHwgbnVsbD4ge1xuXG4gICAgLyogRmFsbGJhY2sgc3RvcmFnZSBpZiBzZXQgKi9cbiAgICBpZiAodGhpcy5mYWxsYmFjaykge1xuICAgICAgcmV0dXJuIHRoaXMuZmFsbGJhY2suZ2V0SXRlbTxUPihrZXkpO1xuICAgIH1cblxuICAgIC8qIE9wZW5pbmcgYSB0cmFzYWN0aW9uIGFuZCByZXF1ZXN0aW5nIHRoZSBpdGVtIGluIGxvY2FsIHN0b3JhZ2UgKi9cbiAgICByZXR1cm4gdGhpcy5nZXRJdGVtRnJvbVRyYW5zYWN0aW9uPFQ+KGtleSk7XG5cbiAgfVxuXG4gIC8qKlxuICAgKiBJbnRlcm5hbCBtZXRob2QgdG8gZmFjdG9yaXplIHRoZSBnZXR0ZXIgZm9yIGdldEl0ZW0gYW5kIHNldEl0ZW0sXG4gICAqIHRoZSBsYXN0IG9uZSBuZWVkaW5nIHRvIGJlIGZyb20gYSBwcmVleGlzdGluZyB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0ga2V5IFRoZSBpdGVtJ3Mga2V5XG4gICAqIEBwYXJhbSB0cmFuc2FjdGlvblBhcmFtIE9wdGlvbmFsIHByZS1leGlzdGluZyB0cmFuc2FjdGlvbiB0byB1c2UgZm9yIHRoZSByZWFkIHJlcXVlc3RcbiAgICogQHJldHVybnMgVGhlIGl0ZW0ncyB2YWx1ZSBpZiB0aGUga2V5IGV4aXN0cywgbnVsbCBvdGhlcndpc2UsIHdyYXBwZWQgaW4gYW4gUnhKUyBPYnNlcnZhYmxlXG4gICAqL1xuICBwcml2YXRlIGdldEl0ZW1Gcm9tVHJhbnNhY3Rpb248VCA9IGFueT4oa2V5OiBzdHJpbmcsIHRyYW5zYWN0aW9uUGFyYW0/OiBJREJPYmplY3RTdG9yZSk6IE9ic2VydmFibGU8VMKgfCBudWxsPiB7XG5cbiAgICBjb25zdCB0cmFuc2FjdGlvbiQgPSB0cmFuc2FjdGlvblBhcmFtID8gb2YodHJhbnNhY3Rpb25QYXJhbSkgOiB0aGlzLnRyYW5zYWN0aW9uKCk7XG5cbiAgICByZXR1cm4gdHJhbnNhY3Rpb24kLnBpcGUoXG4gICAgICBtYXAoKHRyYW5zYWN0aW9uKSA9PiB0cmFuc2FjdGlvbi5nZXQoa2V5KSksXG4gICAgICBtZXJnZU1hcCgocmVxdWVzdCkgPT4ge1xuXG4gICAgICAgIC8qIExpc3RlbmluZyB0byB0aGUgc3VjY2VzcyBldmVudCwgYW5kIHBhc3NpbmcgdGhlIGl0ZW0gdmFsdWUgaWYgZm91bmQsIG51bGwgb3RoZXJ3aXNlICovXG4gICAgICAgIGNvbnN0IHN1Y2Nlc3MgPSAoZnJvbUV2ZW50KHJlcXVlc3QsICdzdWNjZXNzJykgYXMgT2JzZXJ2YWJsZTxFdmVudD4pLnBpcGUoXG4gICAgICAgICAgbWFwKChldmVudCkgPT4gKGV2ZW50LnRhcmdldCBhcyBJREJSZXF1ZXN0KS5yZXN1bHQpLFxuICAgICAgICAgIG1hcCgocmVzdWx0KSA9PiByZXN1bHQgJiYgKHRoaXMuZGF0YVBhdGggaW4gcmVzdWx0KSA/IChyZXN1bHRbdGhpcy5kYXRhUGF0aF0gYXMgVCkgOiBudWxsKVxuICAgICAgICApO1xuXG4gICAgICAgIC8qIE1lcmdpbmcgc3VjY2VzcyBhbmQgZXJyb3JzIGV2ZW50cyBhbmQgYXV0b2Nsb3NpbmcgdGhlIG9ic2VydmFibGUgKi9cbiAgICAgICAgcmV0dXJuIChyYWNlKHN1Y2Nlc3MsIHRoaXMudG9FcnJvck9ic2VydmFibGUocmVxdWVzdCwgYGdldHRlcmApKSBhcyBPYnNlcnZhYmxlPFQgfCBudWxsPilcbiAgICAgICAgICAucGlwZShmaXJzdCgpKTtcbiAgICAgIH0pLFxuICAgICAgZmlyc3QoKVxuICAgICk7XG5cbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIGFuIGl0ZW0gaW4gbG9jYWwgc3RvcmFnZVxuICAgKiBAcGFyYW0ga2V5IFRoZSBpdGVtJ3Mga2V5XG4gICAqIEBwYXJhbSBkYXRhIFRoZSBpdGVtJ3MgdmFsdWUsIG11c3QgTk9UIGJlIG51bGwgb3IgdW5kZWZpbmVkXG4gICAqIEByZXR1cm5zIEFuIFJ4SlMgT2JzZXJ2YWJsZSB0byB3YWl0IHRoZSBlbmQgb2YgdGhlIG9wZXJhdGlvblxuICAgKi9cbiAgc2V0SXRlbShrZXk6IHN0cmluZywgZGF0YTogYW55KTogT2JzZXJ2YWJsZTxib29sZWFuPiB7XG5cbiAgICAvKiBGYWxsYmFjayBzdG9yYWdlIGlmIHNldCAqL1xuICAgIGlmICh0aGlzLmZhbGxiYWNrKSB7XG4gICAgICByZXR1cm4gdGhpcy5mYWxsYmFjay5zZXRJdGVtKGtleSwgZGF0YSk7XG4gICAgfVxuXG4gICAgLyogU3RvcmluZyBudWxsIGlzIG5vdCBjb3JyZWN0bHkgc3VwcG9ydGVkIGJ5IEluZGV4ZWREQiBhbmQgdW5uZWNlc3NhcnkgaGVyZSAqL1xuICAgIGlmIChkYXRhID09IG51bGwpIHtcblxuICAgICAgcmV0dXJuIG9mKHRydWUpO1xuXG4gICAgfVxuXG4gICAgLyogVHJhbnNhY3Rpb24gbXVzdCBiZSB0aGUgc2FtZSBmb3IgcmVhZCBhbmQgd3JpdGUsIHRvIGF2b2lkIGNvbmN1cnJlbmN5IGlzc3VlcyAqL1xuICAgIGNvbnN0IHRyYW5zYWN0aW9uJCA9IHRoaXMudHJhbnNhY3Rpb24oJ3JlYWR3cml0ZScpO1xuICAgIGxldCB0cmFuc2FjdGlvbjogSURCT2JqZWN0U3RvcmU7XG5cbiAgICAgICAgLyogT3BlbmluZyBhIHRyYW5zYWN0aW9uICovXG4gICAgICAgIHJldHVybiB0cmFuc2FjdGlvbiQucGlwZShcbiAgICAgICAgICB0YXAoKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICB0cmFuc2FjdGlvbiA9IHZhbHVlO1xuICAgICAgICAgIH0pLFxuICAgICAgICAgIC8qIENoZWNrIGlmIHRoZSBrZXkgYWxyZWFkeSBleGlzdHMgb3Igbm90ICovXG4gICAgICAgICAgbWVyZ2VNYXAoKCkgPT4gdGhpcy5nZXRJdGVtRnJvbVRyYW5zYWN0aW9uKGtleSwgdHJhbnNhY3Rpb24pKSxcbiAgICAgICAgICBtYXAoKGV4aXN0aW5nRGF0YSkgPT4gKGV4aXN0aW5nRGF0YSA9PSBudWxsKSA/ICdhZGQnIDogJ3B1dCcpLFxuICAgICAgICAgIG1lcmdlTWFwKChtZXRob2QpID0+IHtcblxuICAgICAgICAgICAgbGV0IHJlcXVlc3Q6IElEQlJlcXVlc3Q7XG5cbiAgICAgICAgICAgIC8qIEFkZGluZyBvciB1cGRhdGluZyBsb2NhbCBzdG9yYWdlLCBiYXNlZCBvbiBwcmV2aW91cyBjaGVja2luZyAqL1xuICAgICAgICAgICAgc3dpdGNoIChtZXRob2QpIHtcbiAgICAgICAgICAgICAgY2FzZSAnYWRkJzpcbiAgICAgICAgICAgICAgICByZXF1ZXN0ID0gdHJhbnNhY3Rpb24uYWRkKHsgW3RoaXMuZGF0YVBhdGhdOiBkYXRhIH0sIGtleSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgJ3B1dCc6XG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmVxdWVzdCA9IHRyYW5zYWN0aW9uLnB1dCh7IFt0aGlzLmRhdGFQYXRoXTogZGF0YSB9LCBrZXkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvKiBNZXJnaW5nIHN1Y2Nlc3MgKHBhc3NpbmcgdHJ1ZSkgYW5kIGVycm9yIGV2ZW50cyBhbmQgYXV0b2Nsb3NpbmcgdGhlIG9ic2VydmFibGUgKi9cbiAgICAgICAgICAgIHJldHVybiAocmFjZSh0aGlzLnRvU3VjY2Vzc09ic2VydmFibGUocmVxdWVzdCksIHRoaXMudG9FcnJvck9ic2VydmFibGUocmVxdWVzdCwgYHNldHRlcmApKSBhcyBPYnNlcnZhYmxlPGJvb2xlYW4+KVxuICAgICAgICAgICAgICAucGlwZShmaXJzdCgpKTtcblxuICAgICAgICB9KSxcbiAgICAgICAgZmlyc3QoKVxuICAgICAgKTtcblxuICB9XG5cbiAgLyoqXG4gICAqIERlbGV0ZXMgYW4gaXRlbSBpbiBsb2NhbCBzdG9yYWdlXG4gICAqIEBwYXJhbSBrZXkgVGhlIGl0ZW0ncyBrZXlcbiAgICogQHJldHVybnMgQW4gUnhKUyBPYnNlcnZhYmxlIHRvIHdhaXQgdGhlIGVuZCBvZiB0aGUgb3BlcmF0aW9uXG4gICAqL1xuICByZW1vdmVJdGVtKGtleTogc3RyaW5nKTogT2JzZXJ2YWJsZTxib29sZWFuPiB7XG5cbiAgICAvKiBGYWxsYmFjayBzdG9yYWdlIGlmIHNldCAqL1xuICAgIGlmICh0aGlzLmZhbGxiYWNrKSB7XG4gICAgICByZXR1cm4gdGhpcy5mYWxsYmFjay5yZW1vdmVJdGVtKGtleSk7XG4gICAgfVxuXG4gICAgLyogT3BlbmluZyBhIHRyYW5zYWN0aW9uIGFuZCBjaGVja2luZyBpZiB0aGUgaXRlbSBleGlzdHMgaW4gbG9jYWwgc3RvcmFnZSAqL1xuICAgIHJldHVybiB0aGlzLmdldEl0ZW0oa2V5KS5waXBlKFxuICAgICAgbWVyZ2VNYXAoKGRhdGEpID0+IHtcblxuICAgICAgICAvKiBJZiB0aGUgaXRlbSBleGlzdHMgaW4gbG9jYWwgc3RvcmFnZSAqL1xuICAgICAgICBpZiAoZGF0YSAhPSBudWxsKSB7XG5cbiAgICAgICAgICAvKiBPcGVuaW5nIGEgdHJhbnNhY3Rpb24gKi9cbiAgICAgICAgICByZXR1cm4gdGhpcy50cmFuc2FjdGlvbigncmVhZHdyaXRlJykucGlwZShtZXJnZU1hcCgodHJhbnNhY3Rpb24pID0+IHtcblxuICAgICAgICAgICAgLyogRGVsZXRpbmcgdGhlIGl0ZW0gaW4gbG9jYWwgc3RvcmFnZSAqL1xuICAgICAgICAgICAgY29uc3QgcmVxdWVzdCA9IHRyYW5zYWN0aW9uLmRlbGV0ZShrZXkpO1xuXG4gICAgICAgICAgICAvKiBNZXJnaW5nIHN1Y2Nlc3MgKHBhc3NpbmcgdHJ1ZSkgYW5kIGVycm9yIGV2ZW50cyBhbmQgYXV0b2Nsb3NpbmcgdGhlIG9ic2VydmFibGUgKi9cbiAgICAgICAgICAgIHJldHVybiAocmFjZSh0aGlzLnRvU3VjY2Vzc09ic2VydmFibGUocmVxdWVzdCksIHRoaXMudG9FcnJvck9ic2VydmFibGUocmVxdWVzdCwgYHJlbW92ZXJgKSkgYXMgT2JzZXJ2YWJsZTxib29sZWFuPilcbiAgICAgICAgICAgICAgLnBpcGUoZmlyc3QoKSk7XG5cbiAgICAgICAgICB9KSk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIC8qIFBhc3NpbmcgdHJ1ZSBpZiB0aGUgaXRlbSBkb2VzIG5vdCBleGlzdCBpbiBsb2NhbCBzdG9yYWdlICovXG4gICAgICAgIHJldHVybiBvZih0cnVlKTtcblxuICAgICAgfSksXG4gICAgICBmaXJzdCgpXG4gICAgKTtcblxuICB9XG5cbiAgLyoqXG4gICAqIERlbGV0ZXMgYWxsIGl0ZW1zIGZyb20gbG9jYWwgc3RvcmFnZVxuICAgKiBAcmV0dXJucyBBbiBSeEpTIE9ic2VydmFibGUgdG8gd2FpdCB0aGUgZW5kIG9mIHRoZSBvcGVyYXRpb25cbiAgICovXG4gIGNsZWFyKCk6IE9ic2VydmFibGU8Ym9vbGVhbj4ge1xuXG4gICAgLyogRmFsbGJhY2sgc3RvcmFnZSBpZiBzZXQgKi9cbiAgICBpZiAodGhpcy5mYWxsYmFjaykge1xuICAgICAgcmV0dXJuIHRoaXMuZmFsbGJhY2suY2xlYXIoKTtcbiAgICB9XG5cbiAgICAvKiBPcGVuaW5nIGEgdHJhbnNhY3Rpb24gKi9cbiAgICByZXR1cm4gdGhpcy50cmFuc2FjdGlvbigncmVhZHdyaXRlJykucGlwZShcbiAgICAgIG1lcmdlTWFwKCh0cmFuc2FjdGlvbikgPT4ge1xuXG4gICAgICAgIC8qIERlbGV0aW5nIGFsbCBpdGVtcyBmcm9tIGxvY2FsIHN0b3JhZ2UgKi9cbiAgICAgICAgY29uc3QgcmVxdWVzdCA9IHRyYW5zYWN0aW9uLmNsZWFyKCk7XG5cbiAgICAgICAgLyogTWVyZ2luZyBzdWNjZXNzIChwYXNzaW5nIHRydWUpIGFuZCBlcnJvciBldmVudHMgYW5kIGF1dG9jbG9zaW5nIHRoZSBvYnNlcnZhYmxlICovXG4gICAgICAgIHJldHVybiAocmFjZSh0aGlzLnRvU3VjY2Vzc09ic2VydmFibGUocmVxdWVzdCksIHRoaXMudG9FcnJvck9ic2VydmFibGUocmVxdWVzdCwgYGNsZWFyZXJgKSkgYXMgT2JzZXJ2YWJsZTxib29sZWFuPilcbiAgICAgICAgICAucGlwZShmaXJzdCgpKTtcblxuICAgICAgfSksXG4gICAgICBmaXJzdCgpXG4gICAgKTtcblxuICB9XG5cbiAgLyoqXG4gICAqIENvbm5lY3RzIHRvIEluZGV4ZWREQiBhbmQgY3JlYXRlcyB0aGUgb2JqZWN0IHN0b3JlIG9uIGZpcnN0IHRpbWVcbiAgICovXG4gIHByb3RlY3RlZCBjb25uZWN0KHByZWZpeDogc3RyaW5nIHwgbnVsbCA9IG51bGwpOiB2b2lkIHtcblxuICAgIGxldCByZXF1ZXN0OiBJREJPcGVuREJSZXF1ZXN0O1xuXG4gICAgLyogQ29ubmVjdGluZyB0byBJbmRleGVkREIgKi9cbiAgICB0cnkge1xuXG4gICAgICByZXF1ZXN0ID0gaW5kZXhlZERCLm9wZW4odGhpcy5kYk5hbWUpO1xuXG4gICAgfcKgY2F0Y2ggKGVycm9yKSB7XG5cbiAgICAgIC8qIEZhbGxiYWNrIHN0b3JhZ2UgaWYgSW5kZXhlZERiIGNvbm5lY3Rpb24gaXMgZmFpbGluZyAqL1xuICAgICAgdGhpcy5zZXRGYWxsYmFjayhwcmVmaXgpO1xuXG4gICAgICByZXR1cm47XG5cbiAgICB9XG5cbiAgICAvKiBMaXN0ZW5pbmcgdGhlIGV2ZW50IGZpcmVkIG9uIGZpcnN0IGNvbm5lY3Rpb24sIGNyZWF0aW5nIHRoZSBvYmplY3Qgc3RvcmUgZm9yIGxvY2FsIHN0b3JhZ2UgKi9cbiAgICAoZnJvbUV2ZW50KHJlcXVlc3QsICd1cGdyYWRlbmVlZGVkJykgYXMgT2JzZXJ2YWJsZTxFdmVudD4pXG4gICAgICAucGlwZShmaXJzdCgpKVxuICAgICAgLnN1YnNjcmliZSgoZXZlbnQpID0+IHtcblxuICAgICAgICAvKiBHZXR0aW5nIHRoZSBkYXRhYmFzZSBjb25uZWN0aW9uICovXG4gICAgICAgIGNvbnN0IGRhdGFiYXNlID0gKGV2ZW50LnRhcmdldCBhcyBJREJSZXF1ZXN0KS5yZXN1bHQgYXMgSURCRGF0YWJhc2U7XG5cbiAgICAgICAgLyogQ2hlY2tpbmcgaWYgdGhlIG9iamVjdCBzdG9yZSBhbHJlYWR5IGV4aXN0cywgdG8gYXZvaWQgZXJyb3IgKi9cbiAgICAgICAgaWYgKCFkYXRhYmFzZS5vYmplY3RTdG9yZU5hbWVzLmNvbnRhaW5zKHRoaXMub2JqZWN0U3RvcmVOYW1lKSkge1xuXG4gICAgICAgICAgLyogQ3JlYXRpbmcgdGhlIG9iamVjdCBzdG9yZSBmb3IgbG9jYWwgc3RvcmFnZSAqL1xuICAgICAgICAgIGRhdGFiYXNlLmNyZWF0ZU9iamVjdFN0b3JlKHRoaXMub2JqZWN0U3RvcmVOYW1lKTtcblxuICAgICAgICB9XG5cbiAgICAgIH0pO1xuXG4gICAgLyogTGlzdGVuaW5nIHRoZSBzdWNjZXNzIGV2ZW50IGFuZCBjb252ZXJ0aW5nIHRvIGFuIFJ4SlMgT2JzZXJ2YWJsZSAqL1xuICAgIGNvbnN0IHN1Y2Nlc3MgPSBmcm9tRXZlbnQocmVxdWVzdCwgJ3N1Y2Nlc3MnKSBhcyBPYnNlcnZhYmxlPEV2ZW50PjtcblxuICAgIC8qIE1lcmdpbmcgc3VjY2VzcyBhbmQgZXJyb3JzIGV2ZW50cyAqL1xuICAgIChyYWNlKHN1Y2Nlc3MsIHRoaXMudG9FcnJvck9ic2VydmFibGUocmVxdWVzdCwgYGNvbm5lY3Rpb25gKSkgYXMgT2JzZXJ2YWJsZTxFdmVudD4pXG4gICAgICAucGlwZShmaXJzdCgpKVxuICAgICAgLnN1YnNjcmliZSgoZXZlbnQpID0+IHtcblxuICAgICAgICAvKiBTdG9yaW5nIHRoZSBkYXRhYmFzZSBjb25uZWN0aW9uIGZvciBmdXJ0aGVyIGFjY2VzcyAqL1xuICAgICAgICB0aGlzLmRhdGFiYXNlLm5leHQoKGV2ZW50LnRhcmdldCBhcyBJREJSZXF1ZXN0KS5yZXN1bHQgYXMgSURCRGF0YWJhc2UpO1xuXG4gICAgICB9LCAoKSA9PiB7XG5cbiAgICAgICAgLyogRmFsbGJhY2sgc3RvcmFnZSBpZiBJbmRleGVkRGIgY29ubmVjdGlvbiBpcyBmYWlsaW5nICovXG4gICAgICAgIHRoaXMuc2V0RmFsbGJhY2socHJlZml4KTtcblxuICAgICAgfSk7XG5cbiAgfVxuXG4gIC8qKlxuICAgKiBPcGVucyBhbiBJbmRleGVkREIgdHJhbnNhY3Rpb24gYW5kIGdldHMgdGhlIGxvY2FsIHN0b3JhZ2Ugb2JqZWN0IHN0b3JlXG4gICAqIEBwYXJhbSBtb2RlIERlZmF1bHQgdG8gJ3JlYWRvbmx5JyBmb3IgcmVhZCBvcGVyYXRpb25zLCBvciAncmVhZHdyaXRlJyBmb3Igd3JpdGUgb3BlcmF0aW9uc1xuICAgKiBAcmV0dXJucyBBbiBJbmRleGVkREIgdHJhbnNhY3Rpb24gb2JqZWN0IHN0b3JlLCB3cmFwcGVkIGluIGFuIFJ4SlMgT2JzZXJ2YWJsZVxuICAgKi9cbiAgcHJvdGVjdGVkIHRyYW5zYWN0aW9uKG1vZGU6ICdyZWFkb25seScgfCAncmVhZHdyaXRlJyA9ICdyZWFkb25seScpOiBPYnNlcnZhYmxlPElEQk9iamVjdFN0b3JlPiB7XG5cbiAgICAvKiBGcm9tIHRoZSBJbmRleGVkREIgY29ubmVjdGlvbiwgb3BlbmluZyBhIHRyYW5zYWN0aW9uIGFuZCBnZXR0aW5nIHRoZSBsb2NhbCBzdG9yYWdlIG9iamV0IHN0b3JlICovXG4gICAgcmV0dXJuIHRoaXMuZGF0YWJhc2VcbiAgICAgIC5waXBlKG1hcCgoZGF0YWJhc2UpID0+IGRhdGFiYXNlLnRyYW5zYWN0aW9uKFt0aGlzLm9iamVjdFN0b3JlTmFtZV0sIG1vZGUpLm9iamVjdFN0b3JlKHRoaXMub2JqZWN0U3RvcmVOYW1lKSkpO1xuXG4gIH1cblxuICAvKipcbiAgICogVHJhbnNmb3JtcyBhIEluZGV4ZWREQiBzdWNjZXNzIGV2ZW50IGluIGFuIFJ4SlMgT2JzZXJ2YWJsZVxuICAgKiBAcGFyYW0gcmVxdWVzdCBUaGUgcmVxdWVzdCB0byBsaXN0ZW5cbiAgICogQHJldHVybnMgQSBSeEpTIE9ic2VydmFibGUgd2l0aCB0cnVlIHZhbHVlXG4gICAqL1xuICBwcm90ZWN0ZWQgdG9TdWNjZXNzT2JzZXJ2YWJsZShyZXF1ZXN0OiBJREJSZXF1ZXN0KTogT2JzZXJ2YWJsZTxib29sZWFuPiB7XG5cbiAgICAvKiBUcmFuc2Zvcm1pbmcgYSBJbmRleGVkREIgc3VjY2VzcyBldmVudCBpbiBhbiBSeEpTIE9ic2VydmFibGUgd2l0aCB0cnVlIHZhbHVlICovXG4gICAgcmV0dXJuIChmcm9tRXZlbnQocmVxdWVzdCwgJ3N1Y2Nlc3MnKSBhcyBPYnNlcnZhYmxlPEV2ZW50PilcbiAgICAgIC5waXBlKG1hcCgoKSA9PiB0cnVlKSk7XG5cbiAgfVxuXG4gIC8qKlxuICAgKiBUcmFuc2Zvcm1zIGEgSW5kZXhlZERCIGVycm9yIGV2ZW50IGluIGFuIFJ4SlMgRXJyb3JPYnNlcnZhYmxlXG4gICAqIEBwYXJhbSByZXF1ZXN0IFRoZSByZXF1ZXN0IHRvIGxpc3RlblxuICAgKiBAcGFyYW0gZXJyb3IgT3B0aW9ubmFsIGRldGFpbHMgYWJvdXQgdGhlIGVycm9yJ3Mgb3JpZ2luXG4gICAqIEByZXR1cm5zIEEgUnhKUyBFcnJvck9ic2VydmFibGVcbiAgICovXG4gIHByb3RlY3RlZCB0b0Vycm9yT2JzZXJ2YWJsZShyZXF1ZXN0OiBJREJSZXF1ZXN0LCBlcnJvciA9IGBgKTogT2JzZXJ2YWJsZTxuZXZlcj4ge1xuXG4gICAgLyogVHJhbnNmb3JtaW5nIGEgSW5kZXhlZERCIGVycm9yIGV2ZW50IGluIGFuIFJ4SlMgRXJyb3JPYnNlcnZhYmxlICovXG4gICAgcmV0dXJuIChmcm9tRXZlbnQocmVxdWVzdCwgJ2Vycm9yJykgYXMgT2JzZXJ2YWJsZTxFdmVudD4pXG4gICAgICAucGlwZShtZXJnZU1hcCgoKSA9PiB0aHJvd0Vycm9yKG5ldyBFcnJvcihgSW5kZXhlZERCICR7ZXJyb3J9IGlzc3VlIDogJHsocmVxdWVzdC5lcnJvciBhcyBET01FeGNlcHRpb24pLm1lc3NhZ2V9LmApKSkpO1xuXG4gIH1cblxuICBwcm90ZWN0ZWQgc2V0RmFsbGJhY2socHJlZml4OiBzdHJpbmcgfCBudWxsKTogdm9pZCB7XG5cbiAgICAvKiBXaGVuIHN0b3JhZ2UgaXMgZnVsbHkgZGlzYWJsZWQgaW4gYnJvd3NlciAodmlhIHRoZSBcIkJsb2NrIGFsbCBjb29raWVzXCIgb3B0aW9uKSxcbiAgICAgKiBqdXN0IHRyeWluZyB0byBjaGVjayBgbG9jYWxTdG9yYWdlYCB2YXJpYWJsZSBjYXVzZXMgYSBzZWN1cml0eSBleGNlcHRpb24uXG4gICAgICogUHJldmVudHMgaHR0cHM6Ly9naXRodWIuY29tL2N5cmlsbGV0dXppL2FuZ3VsYXItYXN5bmMtbG9jYWwtc3RvcmFnZS9pc3N1ZXMvMTE4XG4gICAgICovXG4gICAgdHJ5IHtcblxuICAgICAgaWYgKCdnZXRJdGVtJyBpbiBsb2NhbFN0b3JhZ2UpIHtcblxuICAgICAgICAvKiBGYWxsYmFjayB0byBgbG9jYWxTdG9yYWdlYCBpZiBhdmFpbGFibGUgKi9cbiAgICAgICAgdGhpcy5mYWxsYmFjayA9IG5ldyBMb2NhbFN0b3JhZ2VEYXRhYmFzZShwcmVmaXgpO1xuXG4gICAgICB9IGVsc2Uge1xuXG4gICAgICAgIC8qIEZhbGxiYWNrIHRvIG1lbW9yeSBzdG9yYWdlIG90aGVyd2lzZSAqL1xuICAgICAgICB0aGlzLmZhbGxiYWNrID0gbmV3IE1vY2tMb2NhbERhdGFiYXNlKCk7XG5cbiAgICAgIH1cblxuICAgIH0gY2F0Y2gge1xuXG4gICAgICAvKiBGYWxsYmFjayB0byBtZW1vcnkgc3RvcmFnZSBvdGhlcndpc2UgKi9cbiAgICAgIHRoaXMuZmFsbGJhY2sgPSBuZXcgTW9ja0xvY2FsRGF0YWJhc2UoKTtcblxuICAgIH1cblxuICB9XG5cbn1cbiJdfQ==